// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  checkout: (where?: CheckoutWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  lineItem: (where?: LineItemWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  checkout: (where: CheckoutWhereUniqueInput) => CheckoutNullablePromise;
  checkouts: (args?: {
    where?: CheckoutWhereInput;
    orderBy?: CheckoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Checkout>;
  checkoutsConnection: (args?: {
    where?: CheckoutWhereInput;
    orderBy?: CheckoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CheckoutConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  lineItem: (where: LineItemWhereUniqueInput) => LineItemNullablePromise;
  lineItems: (args?: {
    where?: LineItemWhereInput;
    orderBy?: LineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LineItem>;
  lineItemsConnection: (args?: {
    where?: LineItemWhereInput;
    orderBy?: LineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LineItemConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCheckout: (data: CheckoutCreateInput) => CheckoutPromise;
  updateCheckout: (args: {
    data: CheckoutUpdateInput;
    where: CheckoutWhereUniqueInput;
  }) => CheckoutPromise;
  updateManyCheckouts: (args: {
    data: CheckoutUpdateManyMutationInput;
    where?: CheckoutWhereInput;
  }) => BatchPayloadPromise;
  upsertCheckout: (args: {
    where: CheckoutWhereUniqueInput;
    create: CheckoutCreateInput;
    update: CheckoutUpdateInput;
  }) => CheckoutPromise;
  deleteCheckout: (where: CheckoutWhereUniqueInput) => CheckoutPromise;
  deleteManyCheckouts: (where?: CheckoutWhereInput) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createLineItem: (data: LineItemCreateInput) => LineItemPromise;
  updateLineItem: (args: {
    data: LineItemUpdateInput;
    where: LineItemWhereUniqueInput;
  }) => LineItemPromise;
  updateManyLineItems: (args: {
    data: LineItemUpdateManyMutationInput;
    where?: LineItemWhereInput;
  }) => BatchPayloadPromise;
  upsertLineItem: (args: {
    where: LineItemWhereUniqueInput;
    create: LineItemCreateInput;
    update: LineItemUpdateInput;
  }) => LineItemPromise;
  deleteLineItem: (where: LineItemWhereUniqueInput) => LineItemPromise;
  deleteManyLineItems: (where?: LineItemWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  checkout: (
    where?: CheckoutSubscriptionWhereInput
  ) => CheckoutSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  lineItem: (
    where?: LineItemSubscriptionWhereInput
  ) => LineItemSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type KIND_VALUE = "ADULT" | "CHILDREN";

export type STATUS = "PENDING" | "SUCCESS" | "ERROR";

export type LineItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type CheckoutOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "status_ASC"
  | "status_DESC"
  | "data_message_ASC"
  | "data_message_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "last_name_ASC"
  | "last_name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "address_ASC"
  | "address_DESC"
  | "postal_code_ASC"
  | "postal_code_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "cel_phone_ASC"
  | "cel_phone_DESC"
  | "lienItemCount_ASC"
  | "lienItemCount_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "size_ASC"
  | "size_DESC"
  | "image_ASC"
  | "image_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "max_buy_ASC"
  | "max_buy_DESC"
  | "min_buy_ASC"
  | "min_buy_DESC"
  | "discount_for_more_ASC"
  | "discount_for_more_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "last_name_ASC"
  | "last_name_DESC"
  | "is_admin_ASC"
  | "is_admin_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "cel_phone_ASC"
  | "cel_phone_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CheckoutWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  uuid?: Maybe<String>;
}>;

export interface LineItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  product?: Maybe<ProductWhereInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  customer?: Maybe<CustomerWhereInput>;
  AND?: Maybe<LineItemWhereInput[] | LineItemWhereInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  size?: Maybe<String>;
  size_not?: Maybe<String>;
  size_in?: Maybe<String[] | String>;
  size_not_in?: Maybe<String[] | String>;
  size_lt?: Maybe<String>;
  size_lte?: Maybe<String>;
  size_gt?: Maybe<String>;
  size_gte?: Maybe<String>;
  size_contains?: Maybe<String>;
  size_not_contains?: Maybe<String>;
  size_starts_with?: Maybe<String>;
  size_not_starts_with?: Maybe<String>;
  size_ends_with?: Maybe<String>;
  size_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  kind?: Maybe<KIND_VALUE>;
  kind_not?: Maybe<KIND_VALUE>;
  kind_in?: Maybe<KIND_VALUE[] | KIND_VALUE>;
  kind_not_in?: Maybe<KIND_VALUE[] | KIND_VALUE>;
  max_buy?: Maybe<Int>;
  max_buy_not?: Maybe<Int>;
  max_buy_in?: Maybe<Int[] | Int>;
  max_buy_not_in?: Maybe<Int[] | Int>;
  max_buy_lt?: Maybe<Int>;
  max_buy_lte?: Maybe<Int>;
  max_buy_gt?: Maybe<Int>;
  max_buy_gte?: Maybe<Int>;
  min_buy?: Maybe<Int>;
  min_buy_not?: Maybe<Int>;
  min_buy_in?: Maybe<Int[] | Int>;
  min_buy_not_in?: Maybe<Int[] | Int>;
  min_buy_lt?: Maybe<Int>;
  min_buy_lte?: Maybe<Int>;
  min_buy_gt?: Maybe<Int>;
  min_buy_gte?: Maybe<Int>;
  discount_for_more?: Maybe<Int>;
  discount_for_more_not?: Maybe<Int>;
  discount_for_more_in?: Maybe<Int[] | Int>;
  discount_for_more_not_in?: Maybe<Int[] | Int>;
  discount_for_more_lt?: Maybe<Int>;
  discount_for_more_lte?: Maybe<Int>;
  discount_for_more_gt?: Maybe<Int>;
  discount_for_more_gte?: Maybe<Int>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  last_name?: Maybe<String>;
  last_name_not?: Maybe<String>;
  last_name_in?: Maybe<String[] | String>;
  last_name_not_in?: Maybe<String[] | String>;
  last_name_lt?: Maybe<String>;
  last_name_lte?: Maybe<String>;
  last_name_gt?: Maybe<String>;
  last_name_gte?: Maybe<String>;
  last_name_contains?: Maybe<String>;
  last_name_not_contains?: Maybe<String>;
  last_name_starts_with?: Maybe<String>;
  last_name_not_starts_with?: Maybe<String>;
  last_name_ends_with?: Maybe<String>;
  last_name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  postal_code?: Maybe<String>;
  postal_code_not?: Maybe<String>;
  postal_code_in?: Maybe<String[] | String>;
  postal_code_not_in?: Maybe<String[] | String>;
  postal_code_lt?: Maybe<String>;
  postal_code_lte?: Maybe<String>;
  postal_code_gt?: Maybe<String>;
  postal_code_gte?: Maybe<String>;
  postal_code_contains?: Maybe<String>;
  postal_code_not_contains?: Maybe<String>;
  postal_code_starts_with?: Maybe<String>;
  postal_code_not_starts_with?: Maybe<String>;
  postal_code_ends_with?: Maybe<String>;
  postal_code_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  cel_phone?: Maybe<String>;
  cel_phone_not?: Maybe<String>;
  cel_phone_in?: Maybe<String[] | String>;
  cel_phone_not_in?: Maybe<String[] | String>;
  cel_phone_lt?: Maybe<String>;
  cel_phone_lte?: Maybe<String>;
  cel_phone_gt?: Maybe<String>;
  cel_phone_gte?: Maybe<String>;
  cel_phone_contains?: Maybe<String>;
  cel_phone_not_contains?: Maybe<String>;
  cel_phone_starts_with?: Maybe<String>;
  cel_phone_not_starts_with?: Maybe<String>;
  cel_phone_ends_with?: Maybe<String>;
  cel_phone_not_ends_with?: Maybe<String>;
  line_items_some?: Maybe<LineItemWhereInput>;
  lienItemCount?: Maybe<Int>;
  lienItemCount_not?: Maybe<Int>;
  lienItemCount_in?: Maybe<Int[] | Int>;
  lienItemCount_not_in?: Maybe<Int[] | Int>;
  lienItemCount_lt?: Maybe<Int>;
  lienItemCount_lte?: Maybe<Int>;
  lienItemCount_gt?: Maybe<Int>;
  lienItemCount_gte?: Maybe<Int>;
  checkouts_some?: Maybe<CheckoutWhereInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface CheckoutWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uuid?: Maybe<String>;
  uuid_not?: Maybe<String>;
  uuid_in?: Maybe<String[] | String>;
  uuid_not_in?: Maybe<String[] | String>;
  uuid_lt?: Maybe<String>;
  uuid_lte?: Maybe<String>;
  uuid_gt?: Maybe<String>;
  uuid_gte?: Maybe<String>;
  uuid_contains?: Maybe<String>;
  uuid_not_contains?: Maybe<String>;
  uuid_starts_with?: Maybe<String>;
  uuid_not_starts_with?: Maybe<String>;
  uuid_ends_with?: Maybe<String>;
  uuid_not_ends_with?: Maybe<String>;
  customer?: Maybe<CustomerWhereInput>;
  status?: Maybe<STATUS>;
  status_not?: Maybe<STATUS>;
  status_in?: Maybe<STATUS[] | STATUS>;
  status_not_in?: Maybe<STATUS[] | STATUS>;
  data_message?: Maybe<String>;
  data_message_not?: Maybe<String>;
  data_message_in?: Maybe<String[] | String>;
  data_message_not_in?: Maybe<String[] | String>;
  data_message_lt?: Maybe<String>;
  data_message_lte?: Maybe<String>;
  data_message_gt?: Maybe<String>;
  data_message_gte?: Maybe<String>;
  data_message_contains?: Maybe<String>;
  data_message_not_contains?: Maybe<String>;
  data_message_starts_with?: Maybe<String>;
  data_message_not_starts_with?: Maybe<String>;
  data_message_ends_with?: Maybe<String>;
  data_message_not_ends_with?: Maybe<String>;
  AND?: Maybe<CheckoutWhereInput[] | CheckoutWhereInput>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type LineItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  last_name?: Maybe<String>;
  last_name_not?: Maybe<String>;
  last_name_in?: Maybe<String[] | String>;
  last_name_not_in?: Maybe<String[] | String>;
  last_name_lt?: Maybe<String>;
  last_name_lte?: Maybe<String>;
  last_name_gt?: Maybe<String>;
  last_name_gte?: Maybe<String>;
  last_name_contains?: Maybe<String>;
  last_name_not_contains?: Maybe<String>;
  last_name_starts_with?: Maybe<String>;
  last_name_not_starts_with?: Maybe<String>;
  last_name_ends_with?: Maybe<String>;
  last_name_not_ends_with?: Maybe<String>;
  is_admin?: Maybe<Boolean>;
  is_admin_not?: Maybe<Boolean>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  cel_phone?: Maybe<String>;
  cel_phone_not?: Maybe<String>;
  cel_phone_in?: Maybe<String[] | String>;
  cel_phone_not_in?: Maybe<String[] | String>;
  cel_phone_lt?: Maybe<String>;
  cel_phone_lte?: Maybe<String>;
  cel_phone_gt?: Maybe<String>;
  cel_phone_gte?: Maybe<String>;
  cel_phone_contains?: Maybe<String>;
  cel_phone_not_contains?: Maybe<String>;
  cel_phone_starts_with?: Maybe<String>;
  cel_phone_not_starts_with?: Maybe<String>;
  cel_phone_ends_with?: Maybe<String>;
  cel_phone_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CheckoutCreateInput {
  id?: Maybe<ID_Input>;
  uuid: String;
  customer: CustomerCreateOneWithoutCheckoutsInput;
  status?: Maybe<STATUS>;
  data_message?: Maybe<String>;
}

export interface CustomerCreateOneWithoutCheckoutsInput {
  create?: Maybe<CustomerCreateWithoutCheckoutsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutCheckoutsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  email?: Maybe<String>;
  address?: Maybe<String>;
  postal_code?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  cel_phone?: Maybe<String>;
  line_items?: Maybe<LineItemCreateManyWithoutCustomerInput>;
  lienItemCount?: Maybe<Int>;
}

export interface LineItemCreateManyWithoutCustomerInput {
  create?: Maybe<
    LineItemCreateWithoutCustomerInput[] | LineItemCreateWithoutCustomerInput
  >;
  connect?: Maybe<LineItemWhereUniqueInput[] | LineItemWhereUniqueInput>;
}

export interface LineItemCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneInput;
  quantity?: Maybe<Int>;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  price?: Maybe<Float>;
  size?: Maybe<String>;
  image: String;
  kind?: Maybe<KIND_VALUE>;
  max_buy?: Maybe<Int>;
  min_buy?: Maybe<Int>;
  discount_for_more?: Maybe<Int>;
}

export interface CheckoutUpdateInput {
  uuid?: Maybe<String>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutCheckoutsInput>;
  status?: Maybe<STATUS>;
  data_message?: Maybe<String>;
}

export interface CustomerUpdateOneRequiredWithoutCheckoutsInput {
  create?: Maybe<CustomerCreateWithoutCheckoutsInput>;
  update?: Maybe<CustomerUpdateWithoutCheckoutsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutCheckoutsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutCheckoutsDataInput {
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  email?: Maybe<String>;
  address?: Maybe<String>;
  postal_code?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  cel_phone?: Maybe<String>;
  line_items?: Maybe<LineItemUpdateManyWithoutCustomerInput>;
  lienItemCount?: Maybe<Int>;
}

export interface LineItemUpdateManyWithoutCustomerInput {
  create?: Maybe<
    LineItemCreateWithoutCustomerInput[] | LineItemCreateWithoutCustomerInput
  >;
  delete?: Maybe<LineItemWhereUniqueInput[] | LineItemWhereUniqueInput>;
  connect?: Maybe<LineItemWhereUniqueInput[] | LineItemWhereUniqueInput>;
  set?: Maybe<LineItemWhereUniqueInput[] | LineItemWhereUniqueInput>;
  disconnect?: Maybe<LineItemWhereUniqueInput[] | LineItemWhereUniqueInput>;
  update?: Maybe<
    | LineItemUpdateWithWhereUniqueWithoutCustomerInput[]
    | LineItemUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | LineItemUpsertWithWhereUniqueWithoutCustomerInput[]
    | LineItemUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<LineItemScalarWhereInput[] | LineItemScalarWhereInput>;
  updateMany?: Maybe<
    | LineItemUpdateManyWithWhereNestedInput[]
    | LineItemUpdateManyWithWhereNestedInput
  >;
}

export interface LineItemUpdateWithWhereUniqueWithoutCustomerInput {
  where: LineItemWhereUniqueInput;
  data: LineItemUpdateWithoutCustomerDataInput;
}

export interface LineItemUpdateWithoutCustomerDataInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  size?: Maybe<String>;
  image?: Maybe<String>;
  kind?: Maybe<KIND_VALUE>;
  max_buy?: Maybe<Int>;
  min_buy?: Maybe<Int>;
  discount_for_more?: Maybe<Int>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface LineItemUpsertWithWhereUniqueWithoutCustomerInput {
  where: LineItemWhereUniqueInput;
  update: LineItemUpdateWithoutCustomerDataInput;
  create: LineItemCreateWithoutCustomerInput;
}

export interface LineItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<LineItemScalarWhereInput[] | LineItemScalarWhereInput>;
  OR?: Maybe<LineItemScalarWhereInput[] | LineItemScalarWhereInput>;
  NOT?: Maybe<LineItemScalarWhereInput[] | LineItemScalarWhereInput>;
}

export interface LineItemUpdateManyWithWhereNestedInput {
  where: LineItemScalarWhereInput;
  data: LineItemUpdateManyDataInput;
}

export interface LineItemUpdateManyDataInput {
  quantity?: Maybe<Int>;
}

export interface CustomerUpsertWithoutCheckoutsInput {
  update: CustomerUpdateWithoutCheckoutsDataInput;
  create: CustomerCreateWithoutCheckoutsInput;
}

export interface CheckoutUpdateManyMutationInput {
  uuid?: Maybe<String>;
  status?: Maybe<STATUS>;
  data_message?: Maybe<String>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  email?: Maybe<String>;
  address?: Maybe<String>;
  postal_code?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  cel_phone?: Maybe<String>;
  line_items?: Maybe<LineItemCreateManyWithoutCustomerInput>;
  lienItemCount?: Maybe<Int>;
  checkouts?: Maybe<CheckoutCreateManyWithoutCustomerInput>;
}

export interface CheckoutCreateManyWithoutCustomerInput {
  create?: Maybe<
    CheckoutCreateWithoutCustomerInput[] | CheckoutCreateWithoutCustomerInput
  >;
  connect?: Maybe<CheckoutWhereUniqueInput[] | CheckoutWhereUniqueInput>;
}

export interface CheckoutCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  uuid: String;
  status?: Maybe<STATUS>;
  data_message?: Maybe<String>;
}

export interface CustomerUpdateInput {
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  email?: Maybe<String>;
  address?: Maybe<String>;
  postal_code?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  cel_phone?: Maybe<String>;
  line_items?: Maybe<LineItemUpdateManyWithoutCustomerInput>;
  lienItemCount?: Maybe<Int>;
  checkouts?: Maybe<CheckoutUpdateManyWithoutCustomerInput>;
}

export interface CheckoutUpdateManyWithoutCustomerInput {
  create?: Maybe<
    CheckoutCreateWithoutCustomerInput[] | CheckoutCreateWithoutCustomerInput
  >;
  delete?: Maybe<CheckoutWhereUniqueInput[] | CheckoutWhereUniqueInput>;
  connect?: Maybe<CheckoutWhereUniqueInput[] | CheckoutWhereUniqueInput>;
  set?: Maybe<CheckoutWhereUniqueInput[] | CheckoutWhereUniqueInput>;
  disconnect?: Maybe<CheckoutWhereUniqueInput[] | CheckoutWhereUniqueInput>;
  update?: Maybe<
    | CheckoutUpdateWithWhereUniqueWithoutCustomerInput[]
    | CheckoutUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | CheckoutUpsertWithWhereUniqueWithoutCustomerInput[]
    | CheckoutUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<CheckoutScalarWhereInput[] | CheckoutScalarWhereInput>;
  updateMany?: Maybe<
    | CheckoutUpdateManyWithWhereNestedInput[]
    | CheckoutUpdateManyWithWhereNestedInput
  >;
}

export interface CheckoutUpdateWithWhereUniqueWithoutCustomerInput {
  where: CheckoutWhereUniqueInput;
  data: CheckoutUpdateWithoutCustomerDataInput;
}

export interface CheckoutUpdateWithoutCustomerDataInput {
  uuid?: Maybe<String>;
  status?: Maybe<STATUS>;
  data_message?: Maybe<String>;
}

export interface CheckoutUpsertWithWhereUniqueWithoutCustomerInput {
  where: CheckoutWhereUniqueInput;
  update: CheckoutUpdateWithoutCustomerDataInput;
  create: CheckoutCreateWithoutCustomerInput;
}

export interface CheckoutScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uuid?: Maybe<String>;
  uuid_not?: Maybe<String>;
  uuid_in?: Maybe<String[] | String>;
  uuid_not_in?: Maybe<String[] | String>;
  uuid_lt?: Maybe<String>;
  uuid_lte?: Maybe<String>;
  uuid_gt?: Maybe<String>;
  uuid_gte?: Maybe<String>;
  uuid_contains?: Maybe<String>;
  uuid_not_contains?: Maybe<String>;
  uuid_starts_with?: Maybe<String>;
  uuid_not_starts_with?: Maybe<String>;
  uuid_ends_with?: Maybe<String>;
  uuid_not_ends_with?: Maybe<String>;
  status?: Maybe<STATUS>;
  status_not?: Maybe<STATUS>;
  status_in?: Maybe<STATUS[] | STATUS>;
  status_not_in?: Maybe<STATUS[] | STATUS>;
  data_message?: Maybe<String>;
  data_message_not?: Maybe<String>;
  data_message_in?: Maybe<String[] | String>;
  data_message_not_in?: Maybe<String[] | String>;
  data_message_lt?: Maybe<String>;
  data_message_lte?: Maybe<String>;
  data_message_gt?: Maybe<String>;
  data_message_gte?: Maybe<String>;
  data_message_contains?: Maybe<String>;
  data_message_not_contains?: Maybe<String>;
  data_message_starts_with?: Maybe<String>;
  data_message_not_starts_with?: Maybe<String>;
  data_message_ends_with?: Maybe<String>;
  data_message_not_ends_with?: Maybe<String>;
  AND?: Maybe<CheckoutScalarWhereInput[] | CheckoutScalarWhereInput>;
  OR?: Maybe<CheckoutScalarWhereInput[] | CheckoutScalarWhereInput>;
  NOT?: Maybe<CheckoutScalarWhereInput[] | CheckoutScalarWhereInput>;
}

export interface CheckoutUpdateManyWithWhereNestedInput {
  where: CheckoutScalarWhereInput;
  data: CheckoutUpdateManyDataInput;
}

export interface CheckoutUpdateManyDataInput {
  uuid?: Maybe<String>;
  status?: Maybe<STATUS>;
  data_message?: Maybe<String>;
}

export interface CustomerUpdateManyMutationInput {
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  email?: Maybe<String>;
  address?: Maybe<String>;
  postal_code?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  cel_phone?: Maybe<String>;
  lienItemCount?: Maybe<Int>;
}

export interface LineItemCreateInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneInput;
  quantity?: Maybe<Int>;
  customer?: Maybe<CustomerCreateOneWithoutLine_itemsInput>;
}

export interface CustomerCreateOneWithoutLine_itemsInput {
  create?: Maybe<CustomerCreateWithoutLine_itemsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutLine_itemsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  email?: Maybe<String>;
  address?: Maybe<String>;
  postal_code?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  cel_phone?: Maybe<String>;
  lienItemCount?: Maybe<Int>;
  checkouts?: Maybe<CheckoutCreateManyWithoutCustomerInput>;
}

export interface LineItemUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
  customer?: Maybe<CustomerUpdateOneWithoutLine_itemsInput>;
}

export interface CustomerUpdateOneWithoutLine_itemsInput {
  create?: Maybe<CustomerCreateWithoutLine_itemsInput>;
  update?: Maybe<CustomerUpdateWithoutLine_itemsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutLine_itemsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutLine_itemsDataInput {
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  email?: Maybe<String>;
  address?: Maybe<String>;
  postal_code?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  cel_phone?: Maybe<String>;
  lienItemCount?: Maybe<Int>;
  checkouts?: Maybe<CheckoutUpdateManyWithoutCustomerInput>;
}

export interface CustomerUpsertWithoutLine_itemsInput {
  update: CustomerUpdateWithoutLine_itemsDataInput;
  create: CustomerCreateWithoutLine_itemsInput;
}

export interface LineItemUpdateManyMutationInput {
  quantity?: Maybe<Int>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  size?: Maybe<String>;
  image?: Maybe<String>;
  kind?: Maybe<KIND_VALUE>;
  max_buy?: Maybe<Int>;
  min_buy?: Maybe<Int>;
  discount_for_more?: Maybe<Int>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  size?: Maybe<String>;
  image?: Maybe<String>;
  kind?: Maybe<KIND_VALUE>;
  max_buy?: Maybe<Int>;
  min_buy?: Maybe<Int>;
  discount_for_more?: Maybe<Int>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  last_name: String;
  is_admin?: Maybe<Boolean>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  cel_phone?: Maybe<String>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  is_admin?: Maybe<Boolean>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  cel_phone?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  last_name?: Maybe<String>;
  is_admin?: Maybe<Boolean>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  cel_phone?: Maybe<String>;
}

export interface CheckoutSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CheckoutWhereInput>;
  AND?: Maybe<
    CheckoutSubscriptionWhereInput[] | CheckoutSubscriptionWhereInput
  >;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface LineItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LineItemWhereInput>;
  AND?: Maybe<
    LineItemSubscriptionWhereInput[] | LineItemSubscriptionWhereInput
  >;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Checkout {
  id: ID_Output;
  uuid: String;
  status: STATUS;
  data_message?: String;
}

export interface CheckoutPromise extends Promise<Checkout>, Fragmentable {
  id: () => Promise<ID_Output>;
  uuid: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
  status: () => Promise<STATUS>;
  data_message: () => Promise<String>;
}

export interface CheckoutSubscription
  extends Promise<AsyncIterator<Checkout>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uuid: () => Promise<AsyncIterator<String>>;
  customer: <T = CustomerSubscription>() => T;
  status: () => Promise<AsyncIterator<STATUS>>;
  data_message: () => Promise<AsyncIterator<String>>;
}

export interface CheckoutNullablePromise
  extends Promise<Checkout | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uuid: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
  status: () => Promise<STATUS>;
  data_message: () => Promise<String>;
}

export interface Customer {
  id: ID_Output;
  name?: String;
  last_name?: String;
  email?: String;
  address?: String;
  postal_code?: String;
  city?: String;
  state?: String;
  cel_phone?: String;
  lienItemCount: Int;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  last_name: () => Promise<String>;
  email: () => Promise<String>;
  address: () => Promise<String>;
  postal_code: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  cel_phone: () => Promise<String>;
  line_items: <T = FragmentableArray<LineItem>>(args?: {
    where?: LineItemWhereInput;
    orderBy?: LineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lienItemCount: () => Promise<Int>;
  checkouts: <T = FragmentableArray<Checkout>>(args?: {
    where?: CheckoutWhereInput;
    orderBy?: CheckoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  postal_code: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  cel_phone: () => Promise<AsyncIterator<String>>;
  line_items: <T = Promise<AsyncIterator<LineItemSubscription>>>(args?: {
    where?: LineItemWhereInput;
    orderBy?: LineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lienItemCount: () => Promise<AsyncIterator<Int>>;
  checkouts: <T = Promise<AsyncIterator<CheckoutSubscription>>>(args?: {
    where?: CheckoutWhereInput;
    orderBy?: CheckoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  last_name: () => Promise<String>;
  email: () => Promise<String>;
  address: () => Promise<String>;
  postal_code: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  cel_phone: () => Promise<String>;
  line_items: <T = FragmentableArray<LineItem>>(args?: {
    where?: LineItemWhereInput;
    orderBy?: LineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lienItemCount: () => Promise<Int>;
  checkouts: <T = FragmentableArray<Checkout>>(args?: {
    where?: CheckoutWhereInput;
    orderBy?: CheckoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LineItem {
  id: ID_Output;
  quantity: Int;
}

export interface LineItemPromise extends Promise<LineItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  quantity: () => Promise<Int>;
  customer: <T = CustomerPromise>() => T;
}

export interface LineItemSubscription
  extends Promise<AsyncIterator<LineItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  customer: <T = CustomerSubscription>() => T;
}

export interface LineItemNullablePromise
  extends Promise<LineItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  quantity: () => Promise<Int>;
  customer: <T = CustomerPromise>() => T;
}

export interface Product {
  id: ID_Output;
  name: String;
  price: Float;
  size?: String;
  image: String;
  kind: KIND_VALUE;
  max_buy: Int;
  min_buy: Int;
  discount_for_more?: Int;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  size: () => Promise<String>;
  image: () => Promise<String>;
  kind: () => Promise<KIND_VALUE>;
  max_buy: () => Promise<Int>;
  min_buy: () => Promise<Int>;
  discount_for_more: () => Promise<Int>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  size: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  kind: () => Promise<AsyncIterator<KIND_VALUE>>;
  max_buy: () => Promise<AsyncIterator<Int>>;
  min_buy: () => Promise<AsyncIterator<Int>>;
  discount_for_more: () => Promise<AsyncIterator<Int>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  size: () => Promise<String>;
  image: () => Promise<String>;
  kind: () => Promise<KIND_VALUE>;
  max_buy: () => Promise<Int>;
  min_buy: () => Promise<Int>;
  discount_for_more: () => Promise<Int>;
}

export interface CheckoutConnection {
  pageInfo: PageInfo;
  edges: CheckoutEdge[];
}

export interface CheckoutConnectionPromise
  extends Promise<CheckoutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CheckoutEdge>>() => T;
  aggregate: <T = AggregateCheckoutPromise>() => T;
}

export interface CheckoutConnectionSubscription
  extends Promise<AsyncIterator<CheckoutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CheckoutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCheckoutSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CheckoutEdge {
  node: Checkout;
  cursor: String;
}

export interface CheckoutEdgePromise
  extends Promise<CheckoutEdge>,
    Fragmentable {
  node: <T = CheckoutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CheckoutEdgeSubscription
  extends Promise<AsyncIterator<CheckoutEdge>>,
    Fragmentable {
  node: <T = CheckoutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCheckout {
  count: Int;
}

export interface AggregateCheckoutPromise
  extends Promise<AggregateCheckout>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCheckoutSubscription
  extends Promise<AsyncIterator<AggregateCheckout>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LineItemConnection {
  pageInfo: PageInfo;
  edges: LineItemEdge[];
}

export interface LineItemConnectionPromise
  extends Promise<LineItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LineItemEdge>>() => T;
  aggregate: <T = AggregateLineItemPromise>() => T;
}

export interface LineItemConnectionSubscription
  extends Promise<AsyncIterator<LineItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LineItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLineItemSubscription>() => T;
}

export interface LineItemEdge {
  node: LineItem;
  cursor: String;
}

export interface LineItemEdgePromise
  extends Promise<LineItemEdge>,
    Fragmentable {
  node: <T = LineItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LineItemEdgeSubscription
  extends Promise<AsyncIterator<LineItemEdge>>,
    Fragmentable {
  node: <T = LineItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLineItem {
  count: Int;
}

export interface AggregateLineItemPromise
  extends Promise<AggregateLineItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLineItemSubscription
  extends Promise<AsyncIterator<AggregateLineItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
  last_name: String;
  is_admin: Boolean;
  password?: String;
  email?: String;
  cel_phone?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  last_name: () => Promise<String>;
  is_admin: () => Promise<Boolean>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  cel_phone: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  is_admin: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  cel_phone: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  last_name: () => Promise<String>;
  is_admin: () => Promise<Boolean>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  cel_phone: () => Promise<String>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CheckoutSubscriptionPayload {
  mutation: MutationType;
  node: Checkout;
  updatedFields: String[];
  previousValues: CheckoutPreviousValues;
}

export interface CheckoutSubscriptionPayloadPromise
  extends Promise<CheckoutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CheckoutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CheckoutPreviousValuesPromise>() => T;
}

export interface CheckoutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CheckoutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CheckoutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CheckoutPreviousValuesSubscription>() => T;
}

export interface CheckoutPreviousValues {
  id: ID_Output;
  uuid: String;
  status: STATUS;
  data_message?: String;
}

export interface CheckoutPreviousValuesPromise
  extends Promise<CheckoutPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uuid: () => Promise<String>;
  status: () => Promise<STATUS>;
  data_message: () => Promise<String>;
}

export interface CheckoutPreviousValuesSubscription
  extends Promise<AsyncIterator<CheckoutPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uuid: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<STATUS>>;
  data_message: () => Promise<AsyncIterator<String>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  name?: String;
  last_name?: String;
  email?: String;
  address?: String;
  postal_code?: String;
  city?: String;
  state?: String;
  cel_phone?: String;
  lienItemCount: Int;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  last_name: () => Promise<String>;
  email: () => Promise<String>;
  address: () => Promise<String>;
  postal_code: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  cel_phone: () => Promise<String>;
  lienItemCount: () => Promise<Int>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  postal_code: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  cel_phone: () => Promise<AsyncIterator<String>>;
  lienItemCount: () => Promise<AsyncIterator<Int>>;
}

export interface LineItemSubscriptionPayload {
  mutation: MutationType;
  node: LineItem;
  updatedFields: String[];
  previousValues: LineItemPreviousValues;
}

export interface LineItemSubscriptionPayloadPromise
  extends Promise<LineItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LineItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LineItemPreviousValuesPromise>() => T;
}

export interface LineItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LineItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LineItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LineItemPreviousValuesSubscription>() => T;
}

export interface LineItemPreviousValues {
  id: ID_Output;
  quantity: Int;
}

export interface LineItemPreviousValuesPromise
  extends Promise<LineItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
}

export interface LineItemPreviousValuesSubscription
  extends Promise<AsyncIterator<LineItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  price: Float;
  size?: String;
  image: String;
  kind: KIND_VALUE;
  max_buy: Int;
  min_buy: Int;
  discount_for_more?: Int;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  size: () => Promise<String>;
  image: () => Promise<String>;
  kind: () => Promise<KIND_VALUE>;
  max_buy: () => Promise<Int>;
  min_buy: () => Promise<Int>;
  discount_for_more: () => Promise<Int>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  size: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  kind: () => Promise<AsyncIterator<KIND_VALUE>>;
  max_buy: () => Promise<AsyncIterator<Int>>;
  min_buy: () => Promise<AsyncIterator<Int>>;
  discount_for_more: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  last_name: String;
  is_admin: Boolean;
  password?: String;
  email?: String;
  cel_phone?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  last_name: () => Promise<String>;
  is_admin: () => Promise<Boolean>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  cel_phone: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  is_admin: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  cel_phone: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "KIND_VALUE",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "LineItem",
    embedded: false
  },
  {
    name: "Checkout",
    embedded: false
  },
  {
    name: "STATUS",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
